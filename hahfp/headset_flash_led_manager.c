/****************************************************************************
Copyright (C) Cambridge Silicon Radio Ltd. 2004-2010

FILE NAME
    headset_flash_led_manager.h
    
*/

/*!

@file	headset_flash_led_manager.h
@brief converts the user event and state handling into led patterns to be used
	for LED indications.
	
	LEDs can be easily added to specific user events and states without the ned
	for configuring PSKEYS.
	
	To add a new LED pattern for a given event or state
		create the pattern in the .led file
		the led pattern will then be generated automatically using ledpars 
			(see ledparse documentation for details)
		The led pattern will then be available for use in the application.
		(the pattern name (enum) will be in the autogenerated .h file
		
		To add a new state pattern, add the pattern enum name to the 
		headsetStatePatterns table in this file.
		
		On entry to this state, then the desired pattern will display
		
		To add a new event patternm, add the pattern enum name to the 
		headsetEventPatterns table in this file.
		On receiving the event in the headset application, then the 
		desired pattern will play 
		
		
		n.b. state patterns are usually repeating patterns RPT
			 event patterns are usually non repeating patterns
			
    
*/

#ifndef ROM_LEDS

#include "headset_led_manager.h"
#include "headset_events.h"
#include "leds.h"


/*! 
    @brief a led state pattern type
	
	a different led pattern can 
*/
typedef struct
{
	unsigned normal:5;  
	unsigned low_battery:5 ;
	unsigned full_battery:5 ;
	unsigned ha_only:5 ;
	unsigned rx_only:5 ;
} ledStatePattern_t ;
 
/*! 
    @brief table of LED state patterns 
	
	To add a pattern to a particular state, insert it in this table
*/
static const ledStatePattern_t ledStatePatterns [ HEADSET_NUM_STATES ] = 
{
	               	/*normal ,              			lowbatt ,                   		fullbatt ,               			ha_only,					rx_only */	
/*limbo*/	         { 0, 0 , 0 , 0 ,0} ,
/*connectable*/	    { LEDS_BT_MODE_RPT, 		LEDS_LOW_BATT_RPT , 	RED_ON_RPT , 			LEDS_HA_MODE_RPT, 		LEDS_RX_MODE_RPT} ,
/*conndiscoverable*/ 	{ RED_BLUE_ALT_RPT_FAST, 	RED_BLUE_ALT_RPT_FAST , RED_BLUE_ALT_RPT_FAST, 	RED_BLUE_ALT_RPT_FAST ,	RED_BLUE_ALT_RPT_FAST} ,
/*connected*/	    { LEDS_BT_MODE_RPT, 		LEDS_LOW_BATT_RPT , 	RED_ON_RPT , 			LEDS_HA_MODE_RPT, 		LEDS_RX_MODE_RPT } ,
/*outgoing*/	     	{ LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT , 		LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*incoming*/	     	{ RED_BLUE_BOTH_RPT_FAST, 	LEDS_LOW_BATT_RPT , 	RED_BLUE_BOTH_RPT_FAST, LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*active*/	        { LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT ,			LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*testmode*/	     	{ 0, 0 , 0 , 0, 0} ,
/*twc waiting*/	    { LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT , 		LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*twc on hold*/	    { LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT ,	 		LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*twc multicall*/	 	{ LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT , 		LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*incoming on hold*/ 	{ LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT , 		LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT } ,
/*active no sco*/	 	{ LEDS_TALK_RPT, 			LEDS_LOW_BATT_RPT , 	LEDS_TALK_RPT , 		LEDS_HA_MODE_RPT,		LEDS_RX_MODE_RPT },
/*streaming*/	 	{ LEDS_BT_MODE_RPT,			LEDS_LOW_BATT_RPT ,		RED_ON_RPT, 			LEDS_HA_MODE_RPT, 		LEDS_RX_MODE_RPT }		
} ;
									

typedef struct 
{
	unsigned event:8 ;
	unsigned pattern:8 ;
						  
} ledEventPattern_t ;

#define ev(x) (x-EVENTS_MESSAGE_BASE)
#define NUM_LED_EVENTS (5) 
/*! 
    @brief table of LED event patterns
	
	To adda particular led pattern toa user event, add it here
*/
static const ledEventPattern_t ledEventPatterns [NUM_LED_EVENTS] = 
{
	{ ev(EventPowerOn) , LEDS_EVENT_POWER_ON } ,
	{ ev(EventPowerOff) , LEDS_EVENT_POWER_OFF } ,
	{ ev(EventModeHaOnly) , LEDS_EVENT_HA_MODE } ,
	{ ev(EventModeRxOnly) , LEDS_EVENT_RX_MODE } ,
	{ ev(EventModeNormalBt) , LEDS_EVENT_BT_MODE }
} ;


/*! 
    @brief the leds information stored and used to ccontrol the currently playing led pattern
*/
typedef struct ledsInfoTag
{
	unsigned low_battery:1 ;
	unsigned full_battery:1 ;
	unsigned ha_mode:2 ;
	unsigned state:6 ;	
	unsigned reserved:6 ;			
}ledsInfo_t ;



static ledsInfo_t ledsInfo ;


/*!
	@brief coverts headset user events into led patterns to be played

	makes use of the auto generated LED patterns.
	
	Patterns can be defined using the .led file and autogenerated by ledparse
	
	Once generated, patterns can be assigned to events in the ledStatePatterns
	table at the top of this file
	
*/
void ledsIndicateEvent( headsetEvents_t event )  
{
	int i = 0 ;

	/*change the stored state based upon the events recieved - 
		used to update the state indication*/
	switch (event)
	{
		case (EventLowBattery) :
			ledsInfo.low_battery = TRUE ;
			ledsInfo.full_battery = FALSE; 					
		break ;
		case (EventOkBattery) :
			ledsInfo.low_battery = FALSE ;
			ledsInfo.full_battery = FALSE; 							
		break ;
		case (EventModeHaOnly) : /* this is enable ha only mode */
			ledsInfo.ha_mode = 1;
		break;
		case (EventModeRxOnly) : 
			ledsInfo.ha_mode = 2;
		break;
		case (EventModeNormalBt) : 
			ledsInfo.ha_mode = 0;
		break;
		default:
		break ;
	}		
	
		/*the state may need changing after this event has been received*/
	ledsIndicateState( ledsInfo.state )  ;

	for (i = 0 ; i < NUM_LED_EVENTS ; i++ )
	{
		if (ledEventPatterns[i].event == ev(event) )
		{
			ledsPlay( ledEventPatterns[i].pattern ) ;
		}
	}
}


/*!
	@brief coverts headset user states into led patterns to be played

	makes use of the auto generated LED patterns.
	
	Patterns can be defined using the .led file and autogenerated by ledparse
	
	Once generated, patterns can be assigned to states in the ledStatePatterns
	table at the top of this file
	
*/
void ledsIndicateState( headsetState state )  
{		
		/*store the current state
		used for changing led pattern after event changes*/
	ledsInfo.state = state ;
		
	/*switch event to play based on current state*/	
	if (ledsInfo.low_battery)
	{
		ledsPlay( ledStatePatterns[state].low_battery ) ;
	}
	else if (ledsInfo.ha_mode == 1)
	{
		ledsPlay( ledStatePatterns[state].ha_only ) ;
	}
	else if (ledsInfo.ha_mode == 2)
	{
		ledsPlay( ledStatePatterns[state].rx_only ) ;
	}
	else if (ledsInfo.full_battery)
	{
		ledsPlay ( ledStatePatterns[state].full_battery ) ;
	}
	else 
	{
		ledsPlay ( ledStatePatterns[state].normal ) ;
	}
}

#else
	static const int temp ;
#endif

