/****************************************************************************
Copyright (C) Cambridge Silicon Radio Ltd. 2004

FILE NAME
    audio_plugin_if.h
    
DESCRIPTION
	
*/

/*!
@file   audio_plugin_if.h
@brief  Header file for the audio plugin interface.

    The parameters / enums here define the message interface used for the 
    audio plugin.
    i.e This defines the interface between the audio library and the underlying plugin 
    
    The contents of these are similar to the parameters passed into the 
    audio library itself
    
    These messages are generated by the audio library and received in the message handler
    associate with the constant task of an audio plugin.
    
    The company_name_action_plugin.c / h files contain the meessage handler which 
    receives these messages.    
    
    The plugin itself is responsible for acting upon these messages.
     
*/


#ifndef _AUDIO_PLUGIN_INTERFACE_H_
#define _AUDIO_PLUGIN_INTERFACE_H_

#include <library.h>
#include <power.h>

/*the Mode*/
typedef enum AudioModeTag
{
    AUDIO_MODE_MUTE_MIC     ,
    AUDIO_MODE_MUTE_SPEAKER ,
    AUDIO_MODE_MUTE_BOTH    ,    
    AUDIO_MODE_CONNECTED    ,
    AUDIO_MODE_LOOPBACK
}AUDIO_MODE_T ;

/*the audio route*/
typedef enum AudioRouteTag
{
    AUDIO_ROUTE_INTERNAL,
    AUDIO_ROUTE_I2S,
    AUDIO_ROUTE_SPDIF
}AUDIO_ROUTE_T;

/*the audio sink type*/
typedef enum AudioSinkTag
{
    AUDIO_SINK_INVALID  ,
    AUDIO_SINK_SCO      ,
    AUDIO_SINK_ESCO     ,
    AUDIO_SINK_AV
} AUDIO_SINK_T ;

/*the audio power level - taken from power library*/
#define AUDIO_POWER_T power_battery_level

/* Macros for creating messages */
#include <panic.h>
#define MAKE_AUDIO_MESSAGE(TYPE) TYPE##_T *message = PanicUnlessNew(TYPE##_T);
#define MAKE_AUDIO_MESSAGE_WITH_LEN(TYPE, LEN) TYPE##_T *message = (TYPE##_T *) PanicUnlessMalloc(sizeof(TYPE##_T) + LEN);


/*!  Audio Plugin Downstream Interface Messages

	These messages are sent to the audio plugin modules.
	
	An Audio plugin must implement all of the messages below.
	
*/
typedef enum audio_plugin_interface_message_type_tag 
{
	AUDIO_PLUGIN_CONNECT_MSG    = AUDIO_DOWNSTREAM_MESSAGE_BASE,
	AUDIO_PLUGIN_DISCONNECT_MSG ,
	AUDIO_PLUGIN_SET_MODE_MSG   ,
    AUDIO_PLUGIN_SET_ROUTE_MSG  ,
	AUDIO_PLUGIN_SET_VOLUME_MSG , 
	AUDIO_PLUGIN_PLAY_TONE_MSG  ,
	AUDIO_PLUGIN_STOP_TONE_MSG  , 
	AUDIO_PLUGIN_PLAY_TTS_MSG   ,
	AUDIO_PLUGIN_STOP_TTS_MSG  , 
	AUDIO_PLUGIN_VOICE_PROMPTS_INIT_MSG,
    AUDIO_PLUGIN_MIC_SWITCH_MSG,
	AUDIO_PLUGIN_SET_POWER_MSG,
    
	AUDIO_DOWNSTREAM_MESSAGE_TOP	
	
} audio_plugin_interface_message_type_t ; 

/*!  Audio Plugin Upstream Messages

    These messages are sent from the audio plugins to the client Task.
    
    Usually the audio plugins will not send upstream messages, 
    but certain plugins will send information to the application.
*/
typedef enum
{
    AUDIO_PLUGIN_DSP_IND = AUDIO_UPSTREAM_MESSAGE_BASE,
    
    AUDIO_UPSTREAM_MESSAGE_TOP
} audio_plugin_upstream_message_type_t;

/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module. 
	The plugin module should connect the Synchronous connection to its pre
	defined outputs.
*/
typedef struct 
{
		/*! The audio sink to connect*/
	Sink            audio_sink ;
		/*! The type of the audio sink to connect*/
	AUDIO_SINK_T sink_type ;
	    /*! The codec task to use to connect the audio*/
    Task            codec_task ;
 		/*! The volume at which to set the audio */
    uint16          volume ;
    	/*! The rate of the audio stream */
    uint32			rate ;
		/*! whether or not to route mono / stereo audio*/
    bool 			stereo ; 
		/*! The audio mode of connection required*/
    AUDIO_MODE_T	mode ;  
        /*! The audio route of connection required*/
    AUDIO_ROUTE_T   route ;
	        /*! The audio route of connection required*/
    AUDIO_POWER_T   power ;
        /*!plugin specific parameters*/
    const void *    params ;
    	/*! The application task to route upstream plugin messages to*/
    Task            app_task ;
}AUDIO_PLUGIN_CONNECT_MSG_T ;


/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module. 
	The plugin module should connect the Synchronous connection to its pre
	defined outputs.
*/
typedef struct 
{
 		/*! The volume at which to set the audio */
    uint16          volume ;
 		/*! The codec task to use to connect the audio*/
    Task            codec_task ;
}AUDIO_PLUGIN_SET_VOLUME_MSG_T ;


/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module. 
*/
typedef struct 
{
 		/*! The audio connection mode */
    uint16          mode ;
        /*! plugin specific parameters*/
    const void *    params ;
}AUDIO_PLUGIN_SET_MODE_MSG_T ;

/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module. 
*/
typedef struct 
{
 		/*! The audio connection mode */
    uint8           route ;
        /*! plugin specific parameters*/
    const void *    params ;
}AUDIO_PLUGIN_SET_ROUTE_MSG_T ;

/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module. 
*/
typedef struct 
{
 		/*! the tone to be played*/
    ringtone_note * tone;
    	/*! Whether or not to queue the requested tone*/
    bool 	    can_queue ; 
 		/*! The codec task to use to connect the audio*/
    Task            codec_task ;
    	/*! The volume at which to play the tone 0 - current volume*/
    uint16 		tone_volume ;
		/*! whether or not to route mono / stereo audio*/
    bool 		stereo ; 
        /*! The audio route of connection required*/
    AUDIO_ROUTE_T   route ;
}AUDIO_PLUGIN_PLAY_TONE_MSG_T ;

/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module. 
*/
typedef struct 
{
    	/*! the id of the TTS to be played*/
    uint16 id ;
    	/*! the number of bytes in the payload */
    uint16 size_data ;
    	/*! the language to use*/
    uint16 language ;
    	/*! Whether or not to queue the requested tts phrase*/
    bool 	    can_queue ; 
 		/*! The codec task to use to connect the audio*/
    Task            codec_task ;
    	/*! The volume at which to play the tts phrase 0 - current volume*/
    uint16 		tts_volume ;
		/*! whether or not to route mono / stereo audio*/
    bool 		stereo ; 
        /*! The audio route of connection required*/
    AUDIO_ROUTE_T   route ;
    	/*! pointer to the payload for this particular id*/
    uint8 data[1] ;
    
}AUDIO_PLUGIN_PLAY_TTS_MSG_T ;

/*!
	@brief This message is generated by an audio plugin module and sent to the application Task. 
*/
typedef struct 
{
 		/*! The id of the message sent to the application */
    uint16          id ;
 		/*! The value associated with the message id */
    uint16          value ;
}AUDIO_PLUGIN_DSP_IND_T ;

typedef enum
{
    voice_prompts_codec_none,
    voice_prompts_codec_ima_adpcm,
    voice_prompts_codec_sbc,
    voice_prompts_codec_mp3
} voice_prompts_codec;

typedef enum
{
    voice_prompts_type_i2c,
    voice_prompts_type_spi,
    voice_prompts_type_file
} voice_prompts_type;

typedef struct
{
    voice_prompts_type  type;
    union vp_data
    {
        struct i2c_data
        {
            uint16 slv_addr;
            uint16 array_addr;
        } i2c;
        struct spi_data
        {
            uint32 array_addr;
        } spi;
    } addr;
} voice_prompts_index;


/*!
    @brief This message is generated by the audio manager and is issued
    to an audio plugin module. 
*/
typedef struct 
{
    const voice_prompts_index* index;
    uint16                     no_prompts;
    uint16                     no_languages;
}AUDIO_PLUGIN_VOICE_PROMPTS_INIT_MSG_T ;

/*!
	@brief This message is generated by the audio manager and is issued
	to an audio plugin module to configure it's power level 
*/
typedef struct 
{
    	/*! the power level selected */
    AUDIO_POWER_T power;
}AUDIO_PLUGIN_SET_POWER_MSG_T ;

/*!
	@brief This global flag acts as a semaphore that indicates if the audio plugin is busy
    All messages will be queued conditionally on the value of AUDIO_BUSY ; 
    
    This is the main way that the audio library schedules audio conenctions / tone requests etc.
    
    If an audio plugin wishes to prevent tone or disconnection requests being received for
    short periods of time, then this cna be achieved by setting the AUDIO_BUSY flag = TRUE
    
    Note. Setting this to TRUE for long periods of time will result in a build up of audio messages
    which may result in a shortage of memory. As such this is only recommended for short periods 
    of time - see csr_cvc_headset_plugin for an example of use. 
    
*/
extern Task AUDIO_BUSY ;

#endif


